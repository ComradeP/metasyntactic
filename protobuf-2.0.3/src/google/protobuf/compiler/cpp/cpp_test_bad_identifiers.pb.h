// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_google_2fprotobuf_2fcompiler_2fcpp_2fcpp_5ftest_5fbad_5fidentifiers_2eproto__INCLUDED
#define PROTOBUF_google_2fprotobuf_2fcompiler_2fcpp_2fcpp_5ftest_5fbad_5fidentifiers_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2000003
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2000003 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/service.h>

namespace protobuf_unittest {

// Internal implementation detail -- do not call these.
void  protobuf_BuildDesc_google_2fprotobuf_2fcompiler_2fcpp_2fcpp_5ftest_5fbad_5fidentifiers_2eproto();
void protobuf_BuildDesc_google_2fprotobuf_2fcompiler_2fcpp_2fcpp_5ftest_5fbad_5fidentifiers_2eproto_AssignGlobalDescriptors(
    ::google::protobuf::FileDescriptor* file);

class TestConflictingSymbolNames;
class TestConflictingSymbolNames_BuildDescriptors;
class TestConflictingSymbolNames_TypeTraits;
class TestConflictingSymbolNames_Cord;
class TestConflictingSymbolNames_StringPiece;
class TestConflictingSymbolNames_DO;
class DummyMessage;

// ===================================================================

class TestConflictingSymbolNames_BuildDescriptors : public ::google::protobuf::Message {
 public:
  TestConflictingSymbolNames_BuildDescriptors();
  virtual ~TestConflictingSymbolNames_BuildDescriptors();
  
  TestConflictingSymbolNames_BuildDescriptors(const TestConflictingSymbolNames_BuildDescriptors& from);
  
  inline TestConflictingSymbolNames_BuildDescriptors& operator=(const TestConflictingSymbolNames_BuildDescriptors& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TestConflictingSymbolNames_BuildDescriptors& default_instance();
  void Swap(TestConflictingSymbolNames_BuildDescriptors* other);
  
  // implements Message ----------------------------------------------
  
  TestConflictingSymbolNames_BuildDescriptors* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void protobuf_BuildDesc_google_2fprotobuf_2fcompiler_2fcpp_2fcpp_5ftest_5fbad_5fidentifiers_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TestConflictingSymbolNames_BuildDescriptors* default_instance_;
};
// -------------------------------------------------------------------

class TestConflictingSymbolNames_TypeTraits : public ::google::protobuf::Message {
 public:
  TestConflictingSymbolNames_TypeTraits();
  virtual ~TestConflictingSymbolNames_TypeTraits();
  
  TestConflictingSymbolNames_TypeTraits(const TestConflictingSymbolNames_TypeTraits& from);
  
  inline TestConflictingSymbolNames_TypeTraits& operator=(const TestConflictingSymbolNames_TypeTraits& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TestConflictingSymbolNames_TypeTraits& default_instance();
  void Swap(TestConflictingSymbolNames_TypeTraits* other);
  
  // implements Message ----------------------------------------------
  
  TestConflictingSymbolNames_TypeTraits* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void protobuf_BuildDesc_google_2fprotobuf_2fcompiler_2fcpp_2fcpp_5ftest_5fbad_5fidentifiers_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TestConflictingSymbolNames_TypeTraits* default_instance_;
};
// -------------------------------------------------------------------

class TestConflictingSymbolNames_Cord : public ::google::protobuf::Message {
 public:
  TestConflictingSymbolNames_Cord();
  virtual ~TestConflictingSymbolNames_Cord();
  
  TestConflictingSymbolNames_Cord(const TestConflictingSymbolNames_Cord& from);
  
  inline TestConflictingSymbolNames_Cord& operator=(const TestConflictingSymbolNames_Cord& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TestConflictingSymbolNames_Cord& default_instance();
  void Swap(TestConflictingSymbolNames_Cord* other);
  
  // implements Message ----------------------------------------------
  
  TestConflictingSymbolNames_Cord* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void protobuf_BuildDesc_google_2fprotobuf_2fcompiler_2fcpp_2fcpp_5ftest_5fbad_5fidentifiers_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TestConflictingSymbolNames_Cord* default_instance_;
};
// -------------------------------------------------------------------

class TestConflictingSymbolNames_StringPiece : public ::google::protobuf::Message {
 public:
  TestConflictingSymbolNames_StringPiece();
  virtual ~TestConflictingSymbolNames_StringPiece();
  
  TestConflictingSymbolNames_StringPiece(const TestConflictingSymbolNames_StringPiece& from);
  
  inline TestConflictingSymbolNames_StringPiece& operator=(const TestConflictingSymbolNames_StringPiece& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TestConflictingSymbolNames_StringPiece& default_instance();
  void Swap(TestConflictingSymbolNames_StringPiece* other);
  
  // implements Message ----------------------------------------------
  
  TestConflictingSymbolNames_StringPiece* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void protobuf_BuildDesc_google_2fprotobuf_2fcompiler_2fcpp_2fcpp_5ftest_5fbad_5fidentifiers_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TestConflictingSymbolNames_StringPiece* default_instance_;
};
// -------------------------------------------------------------------

class TestConflictingSymbolNames_DO : public ::google::protobuf::Message {
 public:
  TestConflictingSymbolNames_DO();
  virtual ~TestConflictingSymbolNames_DO();
  
  TestConflictingSymbolNames_DO(const TestConflictingSymbolNames_DO& from);
  
  inline TestConflictingSymbolNames_DO& operator=(const TestConflictingSymbolNames_DO& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TestConflictingSymbolNames_DO& default_instance();
  void Swap(TestConflictingSymbolNames_DO* other);
  
  // implements Message ----------------------------------------------
  
  TestConflictingSymbolNames_DO* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void protobuf_BuildDesc_google_2fprotobuf_2fcompiler_2fcpp_2fcpp_5ftest_5fbad_5fidentifiers_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TestConflictingSymbolNames_DO* default_instance_;
};
// -------------------------------------------------------------------

class TestConflictingSymbolNames : public ::google::protobuf::Message {
 public:
  TestConflictingSymbolNames();
  virtual ~TestConflictingSymbolNames();
  
  TestConflictingSymbolNames(const TestConflictingSymbolNames& from);
  
  inline TestConflictingSymbolNames& operator=(const TestConflictingSymbolNames& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TestConflictingSymbolNames& default_instance();
  void Swap(TestConflictingSymbolNames* other);
  
  // implements Message ----------------------------------------------
  
  TestConflictingSymbolNames* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  typedef TestConflictingSymbolNames_BuildDescriptors BuildDescriptors;
  typedef TestConflictingSymbolNames_TypeTraits TypeTraits;
  typedef TestConflictingSymbolNames_Cord Cord;
  typedef TestConflictingSymbolNames_StringPiece StringPiece;
  typedef TestConflictingSymbolNames_DO DO;
  
  // accessors -------------------------------------------------------
  
  // optional int32 input = 1;
  inline bool has_input() const;
  inline void clear_input();
  inline ::google::protobuf::int32 input() const;
  inline void set_input(::google::protobuf::int32 value);
  
  // optional int32 output = 2;
  inline bool has_output() const;
  inline void clear_output();
  inline ::google::protobuf::int32 output() const;
  inline void set_output(::google::protobuf::int32 value);
  
  // optional string length = 3;
  inline bool has_length() const;
  inline void clear_length();
  inline const ::std::string& length() const;
  inline void set_length(const ::std::string& value);
  inline void set_length(const char* value);
  inline ::std::string* mutable_length();
  
  // repeated int32 i = 4;
  inline int i_size() const;
  inline void clear_i();
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >& i() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >* mutable_i();
  inline ::google::protobuf::int32 i(int index) const;
  inline void set_i(int index, ::google::protobuf::int32 value);
  inline void add_i(::google::protobuf::int32 value);
  
  // repeated string new_element = 5 [ctype = STRING_PIECE];
  inline int new_element_size() const;
  inline void clear_new_element();
 private:
  // Hidden due to unknown ctype option.
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& new_element() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_new_element();
  inline const ::std::string& new_element(int index) const;
  inline ::std::string* mutable_new_element(int index);
  inline void set_new_element(int index, const ::std::string& value);
  inline void set_new_element(int index, const char* value);
  inline ::std::string* add_new_element();
  inline void add_new_element(const ::std::string& value);
  inline void add_new_element(const char* value);
 public:
  
  // optional int32 total_size = 6;
  inline bool has_total_size() const;
  inline void clear_total_size();
  inline ::google::protobuf::int32 total_size() const;
  inline void set_total_size(::google::protobuf::int32 value);
  
  // optional int32 tag = 7;
  inline bool has_tag() const;
  inline void clear_tag();
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);
  
  // optional int32 source = 8;
  inline bool has_source() const;
  inline void clear_source();
  inline ::google::protobuf::int32 source() const;
  inline void set_source(::google::protobuf::int32 value);
  
  // optional int32 value = 9;
  inline bool has_value() const;
  inline void clear_value();
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);
  
  // optional int32 file = 10;
  inline bool has_file() const;
  inline void clear_file();
  inline ::google::protobuf::int32 file() const;
  inline void set_file(::google::protobuf::int32 value);
  
  // optional int32 from = 11;
  inline bool has_from() const;
  inline void clear_from();
  inline ::google::protobuf::int32 from() const;
  inline void set_from(::google::protobuf::int32 value);
  
  // optional int32 handle_uninterpreted = 12;
  inline bool has_handle_uninterpreted() const;
  inline void clear_handle_uninterpreted();
  inline ::google::protobuf::int32 handle_uninterpreted() const;
  inline void set_handle_uninterpreted(::google::protobuf::int32 value);
  
  // repeated int32 index = 13;
  inline int index_size() const;
  inline void clear_index();
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >& index() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >* mutable_index();
  inline ::google::protobuf::int32 index(int index) const;
  inline void set_index(int index, ::google::protobuf::int32 value);
  inline void add_index(::google::protobuf::int32 value);
  
  // optional int32 controller = 14;
  inline bool has_controller() const;
  inline void clear_controller();
  inline ::google::protobuf::int32 controller() const;
  inline void set_controller(::google::protobuf::int32 value);
  
  // optional int32 already_here = 15;
  inline bool has_already_here() const;
  inline void clear_already_here();
  inline ::google::protobuf::int32 already_here() const;
  inline void set_already_here(::google::protobuf::int32 value);
  
  // optional uint32 uint32 = 16;
  inline bool has_uint32() const;
  inline void clear_uint32();
  inline ::google::protobuf::uint32 uint32() const;
  inline void set_uint32(::google::protobuf::uint32 value);
  
  // optional uint64 uint64 = 17;
  inline bool has_uint64() const;
  inline void clear_uint64();
  inline ::google::protobuf::uint64 uint64() const;
  inline void set_uint64(::google::protobuf::uint64 value);
  
  // optional string string = 18;
  inline bool has_string() const;
  inline void clear_string();
  inline const ::std::string& string() const;
  inline void set_string(const ::std::string& value);
  inline void set_string(const char* value);
  inline ::std::string* mutable_string();
  
  // optional int32 memset = 19;
  inline bool has_memset() const;
  inline void clear_memset();
  inline ::google::protobuf::int32 memset() const;
  inline void set_memset(::google::protobuf::int32 value);
  
  // optional int32 int32 = 20;
  inline bool has_int32() const;
  inline void clear_int32();
  inline ::google::protobuf::int32 int32() const;
  inline void set_int32(::google::protobuf::int32 value);
  
  // optional int64 int64 = 21;
  inline bool has_int64() const;
  inline void clear_int64();
  inline ::google::protobuf::int64 int64() const;
  inline void set_int64(::google::protobuf::int64 value);
  
  // optional uint32 cached_size = 22;
  inline bool has_cached_size() const;
  inline void clear_cached_size();
  inline ::google::protobuf::uint32 cached_size() const;
  inline void set_cached_size(::google::protobuf::uint32 value);
  
  // optional uint32 extensions = 23;
  inline bool has_extensions() const;
  inline void clear_extensions();
  inline ::google::protobuf::uint32 extensions() const;
  inline void set_extensions(::google::protobuf::uint32 value);
  
  // optional uint32 bit = 24;
  inline bool has_bit() const;
  inline void clear_bit();
  inline ::google::protobuf::uint32 bit() const;
  inline void set_bit(::google::protobuf::uint32 value);
  
  // optional uint32 bits = 25;
  inline bool has_bits() const;
  inline void clear_bits();
  inline ::google::protobuf::uint32 bits() const;
  inline void set_bits(::google::protobuf::uint32 value);
  
  // optional uint32 offsets = 26;
  inline bool has_offsets() const;
  inline void clear_offsets();
  inline ::google::protobuf::uint32 offsets() const;
  inline void set_offsets(::google::protobuf::uint32 value);
  
  // optional uint32 reflection = 27;
  inline bool has_reflection() const;
  inline void clear_reflection();
  inline ::google::protobuf::uint32 reflection() const;
  inline void set_reflection(::google::protobuf::uint32 value);
  
  // optional string some_cord = 28 [ctype = CORD];
  inline bool has_some_cord() const;
  inline void clear_some_cord();
 private:
  // Hidden due to unknown ctype option.
  inline const ::std::string& some_cord() const;
  inline void set_some_cord(const ::std::string& value);
  inline void set_some_cord(const char* value);
  inline ::std::string* mutable_some_cord();
 public:
  
  // optional string some_string_piece = 29 [ctype = STRING_PIECE];
  inline bool has_some_string_piece() const;
  inline void clear_some_string_piece();
 private:
  // Hidden due to unknown ctype option.
  inline const ::std::string& some_string_piece() const;
  inline void set_some_string_piece(const ::std::string& value);
  inline void set_some_string_piece(const char* value);
  inline ::std::string* mutable_some_string_piece();
 public:
  
  // optional uint32 int = 30;
  inline bool has_int_() const;
  inline void clear_int_();
  inline ::google::protobuf::uint32 int_() const;
  inline void set_int_(::google::protobuf::uint32 value);
  
  // optional uint32 friend = 31;
  inline bool has_friend_() const;
  inline void clear_friend_();
  inline ::google::protobuf::uint32 friend_() const;
  inline void set_friend_(::google::protobuf::uint32 value);
  
  // optional .protobuf_unittest.TestConflictingSymbolNames.DO do = 32;
  inline bool has_do_() const;
  inline void clear_do_();
  inline const ::protobuf_unittest::TestConflictingSymbolNames_DO& do_() const;
  inline ::protobuf_unittest::TestConflictingSymbolNames_DO* mutable_do_();
  
  template <typename _proto_TypeTraits>
  inline bool HasExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        TestConflictingSymbolNames, _proto_TypeTraits>& id) const {
    return _extensions_.Has(id.number());
  }
  
  template <typename _proto_TypeTraits>
  inline void ClearExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        TestConflictingSymbolNames, _proto_TypeTraits>& id) {
    _extensions_.ClearExtension(id.number());
  }
  
  template <typename _proto_TypeTraits>
  inline int ExtensionSize(
      const ::google::protobuf::internal::ExtensionIdentifier<
        TestConflictingSymbolNames, _proto_TypeTraits>& id) const {
    return _extensions_.ExtensionSize(id.number());
  }
  
  template <typename _proto_TypeTraits>
  inline typename _proto_TypeTraits::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        TestConflictingSymbolNames, _proto_TypeTraits>& id) const {
    return _proto_TypeTraits::Get(id.number(), _extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline typename _proto_TypeTraits::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        TestConflictingSymbolNames, _proto_TypeTraits>& id) {
    return _proto_TypeTraits::Mutable(id.number(), &_extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        TestConflictingSymbolNames, _proto_TypeTraits>& id,
      typename _proto_TypeTraits::ConstType value) {
    _proto_TypeTraits::Set(id.number(), value, &_extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline typename _proto_TypeTraits::ConstType GetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        TestConflictingSymbolNames, _proto_TypeTraits>& id,
      int index) const {
    return _proto_TypeTraits::Get(id.number(), _extensions_, index);
  }
  
  template <typename _proto_TypeTraits>
  inline typename _proto_TypeTraits::MutableType MutableExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        TestConflictingSymbolNames, _proto_TypeTraits>& id,
      int index) {
    return _proto_TypeTraits::Mutable(id.number(),index,&_extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline void SetExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        TestConflictingSymbolNames, _proto_TypeTraits>& id,
      int index, typename _proto_TypeTraits::ConstType value) {
    _proto_TypeTraits::Set(id.number(), index, value, &_extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline typename _proto_TypeTraits::MutableType AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        TestConflictingSymbolNames, _proto_TypeTraits>& id) {
    return _proto_TypeTraits::Add(id.number(), &_extensions_);
  }
  
  template <typename _proto_TypeTraits>
  inline void AddExtension(
      const ::google::protobuf::internal::ExtensionIdentifier<
        TestConflictingSymbolNames, _proto_TypeTraits>& id,
      typename _proto_TypeTraits::ConstType value) {
    _proto_TypeTraits::Add(id.number(), value, &_extensions_);
  }
 private:
  ::google::protobuf::internal::ExtensionSet _extensions_;
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 input_;
  ::google::protobuf::int32 output_;
  ::std::string* length_;
  static const ::std::string _default_length_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > i_;
  ::google::protobuf::RepeatedPtrField< ::std::string> new_element_;
  ::google::protobuf::int32 total_size_;
  ::google::protobuf::int32 tag_;
  ::google::protobuf::int32 source_;
  ::google::protobuf::int32 value_;
  ::google::protobuf::int32 file_;
  ::google::protobuf::int32 from_;
  ::google::protobuf::int32 handle_uninterpreted_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > index_;
  ::google::protobuf::int32 controller_;
  ::google::protobuf::int32 already_here_;
  ::google::protobuf::uint32 uint32_;
  ::google::protobuf::uint64 uint64_;
  ::std::string* string_;
  static const ::std::string _default_string_;
  ::google::protobuf::int32 memset_;
  ::google::protobuf::int32 int32_;
  ::google::protobuf::int64 int64_;
  ::google::protobuf::uint32 cached_size_;
  ::google::protobuf::uint32 extensions_;
  ::google::protobuf::uint32 bit_;
  ::google::protobuf::uint32 bits_;
  ::google::protobuf::uint32 offsets_;
  ::google::protobuf::uint32 reflection_;
  ::std::string* some_cord_;
  static const ::std::string _default_some_cord_;
  ::std::string* some_string_piece_;
  static const ::std::string _default_some_string_piece_;
  ::google::protobuf::uint32 int__;
  ::google::protobuf::uint32 friend__;
  ::protobuf_unittest::TestConflictingSymbolNames_DO* do__;
  friend void protobuf_BuildDesc_google_2fprotobuf_2fcompiler_2fcpp_2fcpp_5ftest_5fbad_5fidentifiers_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[(32 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TestConflictingSymbolNames* default_instance_;
};
// -------------------------------------------------------------------

class DummyMessage : public ::google::protobuf::Message {
 public:
  DummyMessage();
  virtual ~DummyMessage();
  
  DummyMessage(const DummyMessage& from);
  
  inline DummyMessage& operator=(const DummyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DummyMessage& default_instance();
  void Swap(DummyMessage* other);
  
  // implements Message ----------------------------------------------
  
  DummyMessage* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void protobuf_BuildDesc_google_2fprotobuf_2fcompiler_2fcpp_2fcpp_5ftest_5fbad_5fidentifiers_2eproto_AssignGlobalDescriptors(
      const ::google::protobuf::FileDescriptor* file);
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DummyMessage* default_instance_;
};
// ===================================================================

class TestConflictingMethodNames_Stub;

class TestConflictingMethodNames : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline TestConflictingMethodNames() {};
 public:
  virtual ~TestConflictingMethodNames();
  
  typedef TestConflictingMethodNames_Stub Stub;
  
  static const ::google::protobuf::ServiceDescriptor* descriptor();
  
  virtual void Closure(::google::protobuf::RpcController* controller,
                       const ::protobuf_unittest::DummyMessage* request,
                       ::protobuf_unittest::DummyMessage* response,
                       ::google::protobuf::Closure* done);
  
  // implements Service ----------------------------------------------
  
  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(TestConflictingMethodNames);
};

class TestConflictingMethodNames_Stub : public TestConflictingMethodNames {
 public:
  TestConflictingMethodNames_Stub(::google::protobuf::RpcChannel* channel);
  TestConflictingMethodNames_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~TestConflictingMethodNames_Stub();
  
  inline ::google::protobuf::RpcChannel* channel() { return channel_; }
  
  // implements TestConflictingMethodNames ------------------------------------------
  
  void Closure(::google::protobuf::RpcController* controller,
                       const ::protobuf_unittest::DummyMessage* request,
                       ::protobuf_unittest::DummyMessage* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(TestConflictingMethodNames_Stub);
};


// ===================================================================


// ===================================================================

// TestConflictingSymbolNames_BuildDescriptors

// -------------------------------------------------------------------

// TestConflictingSymbolNames_TypeTraits

// -------------------------------------------------------------------

// TestConflictingSymbolNames_Cord

// -------------------------------------------------------------------

// TestConflictingSymbolNames_StringPiece

// -------------------------------------------------------------------

// TestConflictingSymbolNames_DO

// -------------------------------------------------------------------

// TestConflictingSymbolNames

// optional int32 input = 1;
inline bool TestConflictingSymbolNames::has_input() const {
  return _has_bit(0);
}
inline void TestConflictingSymbolNames::clear_input() {
  input_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 TestConflictingSymbolNames::input() const {
  return input_;
}
inline void TestConflictingSymbolNames::set_input(::google::protobuf::int32 value) {
  _set_bit(0);
  input_ = value;
}

// optional int32 output = 2;
inline bool TestConflictingSymbolNames::has_output() const {
  return _has_bit(1);
}
inline void TestConflictingSymbolNames::clear_output() {
  output_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 TestConflictingSymbolNames::output() const {
  return output_;
}
inline void TestConflictingSymbolNames::set_output(::google::protobuf::int32 value) {
  _set_bit(1);
  output_ = value;
}

// optional string length = 3;
inline bool TestConflictingSymbolNames::has_length() const {
  return _has_bit(2);
}
inline void TestConflictingSymbolNames::clear_length() {
  if (length_ != &_default_length_) {
    length_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& TestConflictingSymbolNames::length() const {
  return *length_;
}
inline void TestConflictingSymbolNames::set_length(const ::std::string& value) {
  _set_bit(2);
  if (length_ == &_default_length_) {
    length_ = new ::std::string;
  }
  length_->assign(value);
}
inline void TestConflictingSymbolNames::set_length(const char* value) {
  _set_bit(2);
  if (length_ == &_default_length_) {
    length_ = new ::std::string;
  }
  length_->assign(value);
}
inline ::std::string* TestConflictingSymbolNames::mutable_length() {
  _set_bit(2);
  if (length_ == &_default_length_) {
    length_ = new ::std::string;
  }
  return length_;
}

// repeated int32 i = 4;
inline int TestConflictingSymbolNames::i_size() const {
  return i_.size();
}
inline void TestConflictingSymbolNames::clear_i() {
  i_.Clear();
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TestConflictingSymbolNames::i() const {
  return i_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TestConflictingSymbolNames::mutable_i() {
  return &i_;
}
inline ::google::protobuf::int32 TestConflictingSymbolNames::i(int index) const {
  return i_.Get(index);
}
inline void TestConflictingSymbolNames::set_i(int index, ::google::protobuf::int32 value) {
  i_.Set(index, value);
}
inline void TestConflictingSymbolNames::add_i(::google::protobuf::int32 value) {
  i_.Add(value);
}

// repeated string new_element = 5 [ctype = STRING_PIECE];
inline int TestConflictingSymbolNames::new_element_size() const {
  return new_element_.size();
}
inline void TestConflictingSymbolNames::clear_new_element() {
  new_element_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TestConflictingSymbolNames::new_element() const {
  return new_element_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TestConflictingSymbolNames::mutable_new_element() {
  return &new_element_;
}
inline const ::std::string& TestConflictingSymbolNames::new_element(int index) const {
  return new_element_.Get(index);
}
inline ::std::string* TestConflictingSymbolNames::mutable_new_element(int index) {
  return new_element_.Mutable(index);
}
inline void TestConflictingSymbolNames::set_new_element(int index, const ::std::string& value) {
  new_element_.Mutable(index)->assign(value);
}
inline void TestConflictingSymbolNames::set_new_element(int index, const char* value) {
  new_element_.Mutable(index)->assign(value);
}
inline ::std::string* TestConflictingSymbolNames::add_new_element() {
  return new_element_.Add();
}
inline void TestConflictingSymbolNames::add_new_element(const ::std::string& value) {
  new_element_.Add()->assign(value);
}
inline void TestConflictingSymbolNames::add_new_element(const char* value) {
  new_element_.Add()->assign(value);
}

// optional int32 total_size = 6;
inline bool TestConflictingSymbolNames::has_total_size() const {
  return _has_bit(5);
}
inline void TestConflictingSymbolNames::clear_total_size() {
  total_size_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 TestConflictingSymbolNames::total_size() const {
  return total_size_;
}
inline void TestConflictingSymbolNames::set_total_size(::google::protobuf::int32 value) {
  _set_bit(5);
  total_size_ = value;
}

// optional int32 tag = 7;
inline bool TestConflictingSymbolNames::has_tag() const {
  return _has_bit(6);
}
inline void TestConflictingSymbolNames::clear_tag() {
  tag_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 TestConflictingSymbolNames::tag() const {
  return tag_;
}
inline void TestConflictingSymbolNames::set_tag(::google::protobuf::int32 value) {
  _set_bit(6);
  tag_ = value;
}

// optional int32 source = 8;
inline bool TestConflictingSymbolNames::has_source() const {
  return _has_bit(7);
}
inline void TestConflictingSymbolNames::clear_source() {
  source_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 TestConflictingSymbolNames::source() const {
  return source_;
}
inline void TestConflictingSymbolNames::set_source(::google::protobuf::int32 value) {
  _set_bit(7);
  source_ = value;
}

// optional int32 value = 9;
inline bool TestConflictingSymbolNames::has_value() const {
  return _has_bit(8);
}
inline void TestConflictingSymbolNames::clear_value() {
  value_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 TestConflictingSymbolNames::value() const {
  return value_;
}
inline void TestConflictingSymbolNames::set_value(::google::protobuf::int32 value) {
  _set_bit(8);
  value_ = value;
}

// optional int32 file = 10;
inline bool TestConflictingSymbolNames::has_file() const {
  return _has_bit(9);
}
inline void TestConflictingSymbolNames::clear_file() {
  file_ = 0;
  _clear_bit(9);
}
inline ::google::protobuf::int32 TestConflictingSymbolNames::file() const {
  return file_;
}
inline void TestConflictingSymbolNames::set_file(::google::protobuf::int32 value) {
  _set_bit(9);
  file_ = value;
}

// optional int32 from = 11;
inline bool TestConflictingSymbolNames::has_from() const {
  return _has_bit(10);
}
inline void TestConflictingSymbolNames::clear_from() {
  from_ = 0;
  _clear_bit(10);
}
inline ::google::protobuf::int32 TestConflictingSymbolNames::from() const {
  return from_;
}
inline void TestConflictingSymbolNames::set_from(::google::protobuf::int32 value) {
  _set_bit(10);
  from_ = value;
}

// optional int32 handle_uninterpreted = 12;
inline bool TestConflictingSymbolNames::has_handle_uninterpreted() const {
  return _has_bit(11);
}
inline void TestConflictingSymbolNames::clear_handle_uninterpreted() {
  handle_uninterpreted_ = 0;
  _clear_bit(11);
}
inline ::google::protobuf::int32 TestConflictingSymbolNames::handle_uninterpreted() const {
  return handle_uninterpreted_;
}
inline void TestConflictingSymbolNames::set_handle_uninterpreted(::google::protobuf::int32 value) {
  _set_bit(11);
  handle_uninterpreted_ = value;
}

// repeated int32 index = 13;
inline int TestConflictingSymbolNames::index_size() const {
  return index_.size();
}
inline void TestConflictingSymbolNames::clear_index() {
  index_.Clear();
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TestConflictingSymbolNames::index() const {
  return index_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TestConflictingSymbolNames::mutable_index() {
  return &index_;
}
inline ::google::protobuf::int32 TestConflictingSymbolNames::index(int index) const {
  return index_.Get(index);
}
inline void TestConflictingSymbolNames::set_index(int index, ::google::protobuf::int32 value) {
  index_.Set(index, value);
}
inline void TestConflictingSymbolNames::add_index(::google::protobuf::int32 value) {
  index_.Add(value);
}

// optional int32 controller = 14;
inline bool TestConflictingSymbolNames::has_controller() const {
  return _has_bit(13);
}
inline void TestConflictingSymbolNames::clear_controller() {
  controller_ = 0;
  _clear_bit(13);
}
inline ::google::protobuf::int32 TestConflictingSymbolNames::controller() const {
  return controller_;
}
inline void TestConflictingSymbolNames::set_controller(::google::protobuf::int32 value) {
  _set_bit(13);
  controller_ = value;
}

// optional int32 already_here = 15;
inline bool TestConflictingSymbolNames::has_already_here() const {
  return _has_bit(14);
}
inline void TestConflictingSymbolNames::clear_already_here() {
  already_here_ = 0;
  _clear_bit(14);
}
inline ::google::protobuf::int32 TestConflictingSymbolNames::already_here() const {
  return already_here_;
}
inline void TestConflictingSymbolNames::set_already_here(::google::protobuf::int32 value) {
  _set_bit(14);
  already_here_ = value;
}

// optional uint32 uint32 = 16;
inline bool TestConflictingSymbolNames::has_uint32() const {
  return _has_bit(15);
}
inline void TestConflictingSymbolNames::clear_uint32() {
  uint32_ = 0u;
  _clear_bit(15);
}
inline ::google::protobuf::uint32 TestConflictingSymbolNames::uint32() const {
  return uint32_;
}
inline void TestConflictingSymbolNames::set_uint32(::google::protobuf::uint32 value) {
  _set_bit(15);
  uint32_ = value;
}

// optional uint64 uint64 = 17;
inline bool TestConflictingSymbolNames::has_uint64() const {
  return _has_bit(16);
}
inline void TestConflictingSymbolNames::clear_uint64() {
  uint64_ = GOOGLE_ULONGLONG(0);
  _clear_bit(16);
}
inline ::google::protobuf::uint64 TestConflictingSymbolNames::uint64() const {
  return uint64_;
}
inline void TestConflictingSymbolNames::set_uint64(::google::protobuf::uint64 value) {
  _set_bit(16);
  uint64_ = value;
}

// optional string string = 18;
inline bool TestConflictingSymbolNames::has_string() const {
  return _has_bit(17);
}
inline void TestConflictingSymbolNames::clear_string() {
  if (string_ != &_default_string_) {
    string_->clear();
  }
  _clear_bit(17);
}
inline const ::std::string& TestConflictingSymbolNames::string() const {
  return *string_;
}
inline void TestConflictingSymbolNames::set_string(const ::std::string& value) {
  _set_bit(17);
  if (string_ == &_default_string_) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline void TestConflictingSymbolNames::set_string(const char* value) {
  _set_bit(17);
  if (string_ == &_default_string_) {
    string_ = new ::std::string;
  }
  string_->assign(value);
}
inline ::std::string* TestConflictingSymbolNames::mutable_string() {
  _set_bit(17);
  if (string_ == &_default_string_) {
    string_ = new ::std::string;
  }
  return string_;
}

// optional int32 memset = 19;
inline bool TestConflictingSymbolNames::has_memset() const {
  return _has_bit(18);
}
inline void TestConflictingSymbolNames::clear_memset() {
  memset_ = 0;
  _clear_bit(18);
}
inline ::google::protobuf::int32 TestConflictingSymbolNames::memset() const {
  return memset_;
}
inline void TestConflictingSymbolNames::set_memset(::google::protobuf::int32 value) {
  _set_bit(18);
  memset_ = value;
}

// optional int32 int32 = 20;
inline bool TestConflictingSymbolNames::has_int32() const {
  return _has_bit(19);
}
inline void TestConflictingSymbolNames::clear_int32() {
  int32_ = 0;
  _clear_bit(19);
}
inline ::google::protobuf::int32 TestConflictingSymbolNames::int32() const {
  return int32_;
}
inline void TestConflictingSymbolNames::set_int32(::google::protobuf::int32 value) {
  _set_bit(19);
  int32_ = value;
}

// optional int64 int64 = 21;
inline bool TestConflictingSymbolNames::has_int64() const {
  return _has_bit(20);
}
inline void TestConflictingSymbolNames::clear_int64() {
  int64_ = GOOGLE_LONGLONG(0);
  _clear_bit(20);
}
inline ::google::protobuf::int64 TestConflictingSymbolNames::int64() const {
  return int64_;
}
inline void TestConflictingSymbolNames::set_int64(::google::protobuf::int64 value) {
  _set_bit(20);
  int64_ = value;
}

// optional uint32 cached_size = 22;
inline bool TestConflictingSymbolNames::has_cached_size() const {
  return _has_bit(21);
}
inline void TestConflictingSymbolNames::clear_cached_size() {
  cached_size_ = 0u;
  _clear_bit(21);
}
inline ::google::protobuf::uint32 TestConflictingSymbolNames::cached_size() const {
  return cached_size_;
}
inline void TestConflictingSymbolNames::set_cached_size(::google::protobuf::uint32 value) {
  _set_bit(21);
  cached_size_ = value;
}

// optional uint32 extensions = 23;
inline bool TestConflictingSymbolNames::has_extensions() const {
  return _has_bit(22);
}
inline void TestConflictingSymbolNames::clear_extensions() {
  extensions_ = 0u;
  _clear_bit(22);
}
inline ::google::protobuf::uint32 TestConflictingSymbolNames::extensions() const {
  return extensions_;
}
inline void TestConflictingSymbolNames::set_extensions(::google::protobuf::uint32 value) {
  _set_bit(22);
  extensions_ = value;
}

// optional uint32 bit = 24;
inline bool TestConflictingSymbolNames::has_bit() const {
  return _has_bit(23);
}
inline void TestConflictingSymbolNames::clear_bit() {
  bit_ = 0u;
  _clear_bit(23);
}
inline ::google::protobuf::uint32 TestConflictingSymbolNames::bit() const {
  return bit_;
}
inline void TestConflictingSymbolNames::set_bit(::google::protobuf::uint32 value) {
  _set_bit(23);
  bit_ = value;
}

// optional uint32 bits = 25;
inline bool TestConflictingSymbolNames::has_bits() const {
  return _has_bit(24);
}
inline void TestConflictingSymbolNames::clear_bits() {
  bits_ = 0u;
  _clear_bit(24);
}
inline ::google::protobuf::uint32 TestConflictingSymbolNames::bits() const {
  return bits_;
}
inline void TestConflictingSymbolNames::set_bits(::google::protobuf::uint32 value) {
  _set_bit(24);
  bits_ = value;
}

// optional uint32 offsets = 26;
inline bool TestConflictingSymbolNames::has_offsets() const {
  return _has_bit(25);
}
inline void TestConflictingSymbolNames::clear_offsets() {
  offsets_ = 0u;
  _clear_bit(25);
}
inline ::google::protobuf::uint32 TestConflictingSymbolNames::offsets() const {
  return offsets_;
}
inline void TestConflictingSymbolNames::set_offsets(::google::protobuf::uint32 value) {
  _set_bit(25);
  offsets_ = value;
}

// optional uint32 reflection = 27;
inline bool TestConflictingSymbolNames::has_reflection() const {
  return _has_bit(26);
}
inline void TestConflictingSymbolNames::clear_reflection() {
  reflection_ = 0u;
  _clear_bit(26);
}
inline ::google::protobuf::uint32 TestConflictingSymbolNames::reflection() const {
  return reflection_;
}
inline void TestConflictingSymbolNames::set_reflection(::google::protobuf::uint32 value) {
  _set_bit(26);
  reflection_ = value;
}

// optional string some_cord = 28 [ctype = CORD];
inline bool TestConflictingSymbolNames::has_some_cord() const {
  return _has_bit(27);
}
inline void TestConflictingSymbolNames::clear_some_cord() {
  if (some_cord_ != &_default_some_cord_) {
    some_cord_->clear();
  }
  _clear_bit(27);
}
inline const ::std::string& TestConflictingSymbolNames::some_cord() const {
  return *some_cord_;
}
inline void TestConflictingSymbolNames::set_some_cord(const ::std::string& value) {
  _set_bit(27);
  if (some_cord_ == &_default_some_cord_) {
    some_cord_ = new ::std::string;
  }
  some_cord_->assign(value);
}
inline void TestConflictingSymbolNames::set_some_cord(const char* value) {
  _set_bit(27);
  if (some_cord_ == &_default_some_cord_) {
    some_cord_ = new ::std::string;
  }
  some_cord_->assign(value);
}
inline ::std::string* TestConflictingSymbolNames::mutable_some_cord() {
  _set_bit(27);
  if (some_cord_ == &_default_some_cord_) {
    some_cord_ = new ::std::string;
  }
  return some_cord_;
}

// optional string some_string_piece = 29 [ctype = STRING_PIECE];
inline bool TestConflictingSymbolNames::has_some_string_piece() const {
  return _has_bit(28);
}
inline void TestConflictingSymbolNames::clear_some_string_piece() {
  if (some_string_piece_ != &_default_some_string_piece_) {
    some_string_piece_->clear();
  }
  _clear_bit(28);
}
inline const ::std::string& TestConflictingSymbolNames::some_string_piece() const {
  return *some_string_piece_;
}
inline void TestConflictingSymbolNames::set_some_string_piece(const ::std::string& value) {
  _set_bit(28);
  if (some_string_piece_ == &_default_some_string_piece_) {
    some_string_piece_ = new ::std::string;
  }
  some_string_piece_->assign(value);
}
inline void TestConflictingSymbolNames::set_some_string_piece(const char* value) {
  _set_bit(28);
  if (some_string_piece_ == &_default_some_string_piece_) {
    some_string_piece_ = new ::std::string;
  }
  some_string_piece_->assign(value);
}
inline ::std::string* TestConflictingSymbolNames::mutable_some_string_piece() {
  _set_bit(28);
  if (some_string_piece_ == &_default_some_string_piece_) {
    some_string_piece_ = new ::std::string;
  }
  return some_string_piece_;
}

// optional uint32 int = 30;
inline bool TestConflictingSymbolNames::has_int_() const {
  return _has_bit(29);
}
inline void TestConflictingSymbolNames::clear_int_() {
  int__ = 0u;
  _clear_bit(29);
}
inline ::google::protobuf::uint32 TestConflictingSymbolNames::int_() const {
  return int__;
}
inline void TestConflictingSymbolNames::set_int_(::google::protobuf::uint32 value) {
  _set_bit(29);
  int__ = value;
}

// optional uint32 friend = 31;
inline bool TestConflictingSymbolNames::has_friend_() const {
  return _has_bit(30);
}
inline void TestConflictingSymbolNames::clear_friend_() {
  friend__ = 0u;
  _clear_bit(30);
}
inline ::google::protobuf::uint32 TestConflictingSymbolNames::friend_() const {
  return friend__;
}
inline void TestConflictingSymbolNames::set_friend_(::google::protobuf::uint32 value) {
  _set_bit(30);
  friend__ = value;
}

// optional .protobuf_unittest.TestConflictingSymbolNames.DO do = 32;
inline bool TestConflictingSymbolNames::has_do_() const {
  return _has_bit(31);
}
inline void TestConflictingSymbolNames::clear_do_() {
  if (do__ != NULL) do__->::protobuf_unittest::TestConflictingSymbolNames_DO::Clear();
  _clear_bit(31);
}
inline const ::protobuf_unittest::TestConflictingSymbolNames_DO& TestConflictingSymbolNames::do_() const {
  return do__ != NULL ? *do__ : *default_instance_->do__;
}
inline ::protobuf_unittest::TestConflictingSymbolNames_DO* TestConflictingSymbolNames::mutable_do_() {
  _set_bit(31);
  if (do__ == NULL) do__ = new ::protobuf_unittest::TestConflictingSymbolNames_DO;
  return do__;
}

// -------------------------------------------------------------------

// DummyMessage


}  // namespace protobuf_unittest
#endif  // PROTOBUF_google_2fprotobuf_2fcompiler_2fcpp_2fcpp_5ftest_5fbad_5fidentifiers_2eproto__INCLUDED
